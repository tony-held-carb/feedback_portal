============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0 -- /home/theld/miniconda3/envs/mini_conda_02/bin/python
cachedir: .pytest_cache
rootdir: /home/theld/code/git_repos/feedback_portal
configfile: pytest.ini
plugins: anyio-4.7.0, base-url-2.1.0, asyncio-1.1.0, playwright-0.7.0
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... [DEBUG] Using DB URI: postgresql+psycopg2://methane:methaneCH4@prj-bus-methane-aurora-postgresql-instance-1.cdae8kkz3fpi.us-west-2.rds.amazonaws.com/plumetracker
collected 87 items

tests/e2e/test_delete_testing_data.py::test_delete_testing_range_page_loads[chromium] /home/theld/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/driver/node: /lib64/libm.so.6: version `GLIBC_2.27' not found (required by /home/theld/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/driver/node)
/home/theld/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/driver/node: /lib64/libc.so.6: version `GLIBC_2.27' not found (required by /home/theld/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/driver/node)
/home/theld/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/driver/node: /lib64/libc.so.6: version `GLIBC_2.28' not found (required by /home/theld/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/driver/node)
ERROR
tests/e2e/test_delete_testing_data.py::test_min_max_id_inputs[chromium] ERROR
tests/e2e/test_delete_testing_data.py::test_dry_run_checkbox_and_preview[chromium] ERROR
tests/e2e/test_delete_testing_data.py::test_delete_button_and_real_delete[chromium] ERROR
tests/e2e/test_delete_testing_data.py::test_diagnostics_messaging[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_upload_page_loads[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_input_exists[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_drop_zone_exists[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_invalid_file_upload[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_empty_file_upload[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_large_file_upload[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::TestUploadPageElements::test_page_structure[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::TestUploadPageElements::test_form_structure[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::TestUploadPageElements::test_accessibility_features[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::test_list_staged_diagnostics_overlay[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::test_upload_file_only[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::test_discard_staged_file_only[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::test_upload_multiple_files_only[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::test_discard_each_staged_file_separately[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::test_upload_malformed_file_only[chromium] ERROR
tests/e2e/test_excel_upload_workflows.py::test_discard_malformed_file_only[chromium] ERROR
tests/e2e/test_feedback_updates.py::test_feedback_updates_page_loads[chromium] ERROR
tests/e2e/test_feedback_updates.py::test_feedback_updates_filter_functionality[chromium] ERROR
tests/e2e/test_feedback_updates.py::test_feedback_updates_download_csv_button[chromium] ERROR
tests/e2e/test_feedback_updates.py::test_feedback_updates_accessibility[chromium] ERROR
tests/e2e/test_feedback_updates.py::test_feedback_updates_empty_state[chromium] ERROR
tests/e2e/test_feedback_updates.py::test_feedback_updates_long_text_overflow[chromium] ERROR
tests/e2e/test_feedback_updates.py::test_feedback_updates_special_characters[chromium] ERROR
tests/e2e/test_feedback_updates.py::test_feedback_updates_date_range_boundaries[chromium] ERROR
tests/e2e/test_feedback_updates.py::test_feedback_updates_csv_download_with_filters[chromium] ERROR
tests/e2e/test_feedback_updates.py::test_feedback_updates_rapid_filter_changes[chromium] ERROR
tests/e2e/test_feedback_updates.py::test_feedback_updates_large_data_set[chromium] ERROR
tests/e2e/test_homepage.py::test_homepage_loads[chromium] ERROR
tests/e2e/test_homepage.py::test_homepage_empty_state[chromium] ERROR
tests/e2e/test_homepage.py::test_homepage_navigation_menu[chromium] ERROR
tests/e2e/test_homepage.py::test_homepage_accessibility[chromium] ERROR
tests/e2e/test_homepage.py::test_homepage_card_content_and_links[chromium] ERROR
tests/e2e/test_homepage.py::test_homepage_card_navigation[chromium] ERROR
tests/e2e/test_homepage.py::test_homepage_pagination_or_scrolling[chromium] ERROR
tests/e2e/test_homepage.py::test_homepage_special_characters_and_long_text[chromium] ERROR
tests/e2e/test_javascript_logging.py::test_diagnostics_overlay_on_diagnostic_test_page[chromium] ERROR
tests/e2e/test_list_uploads.py::test_list_uploads_page_loads[chromium] ERROR
tests/e2e/test_list_uploads.py::test_list_uploads_file_links[chromium] ERROR
tests/e2e/test_list_uploads.py::test_list_uploads_accessibility[chromium] ERROR
tests/e2e/test_list_uploads.py::test_list_uploads_empty_state[chromium] ERROR
tests/e2e/test_menu_calsmp_help.py::test_calsmp_help_menu_links[chromium] ERROR
tests/e2e/test_menu_developer_utilities.py::test_developer_utilities_menu_links_and_create_incidence[chromium] ERROR
tests/e2e/test_review_staged.py::test_hide_changes_checkbox[chromium] ERROR
tests/e2e/test_review_staged.py::test_field_search_filter[chromium] ERROR
tests/e2e/test_review_staged.py::test_change_summary_card[chromium] ERROR
tests/e2e/test_review_staged.py::test_cancel_and_save_buttons[chromium] ERROR
tests/e2e/test_review_staged.py::test_confirm_checkboxes[chromium] ERROR
tests/e2e/test_review_staged.py::test_incremental_upload[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_02_bad_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_02_bad_data.xlsx] ERROR
tests/e2e/test_review_staged.py::test_incremental_upload[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_03_blank.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_03_blank.xlsx] ERROR
tests/e2e/test_review_staged.py::test_incremental_upload[chromium-feedback_forms/testing_versions/standard/generic_operator_feedback_v002_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_01_good_data.xlsx] ERROR
tests/e2e/test_review_staged.py::test_incremental_upload[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v070_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_01_good_data_update.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_01_good_data_update.xlsx] ERROR
tests/e2e/test_review_staged.py::test_incremental_upload[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v071_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_02_bad_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_02_bad_data.xlsx] ERROR
tests/e2e/test_review_staged.py::test_incremental_upload[chromium-feedback_forms/testing_versions/standard/oil_and_gas_operator_feedback_v070_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/generic_operator_feedback_v002_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/generic_operator_feedback_v002_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/generic_operator_feedback_v002_test_02_bad_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/generic_operator_feedback_v002_test_02_bad_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v070_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v070_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v070_test_02_bad_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v070_test_02_bad_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v071_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v071_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v071_test_02_bad_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v071_test_02_bad_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/oil_and_gas_operator_feedback_v070_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/oil_and_gas_operator_feedback_v070_test_01_good_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/oil_and_gas_operator_feedback_v070_test_02_bad_data.xlsx] ERROR
tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/oil_and_gas_operator_feedback_v070_test_02_bad_data.xlsx] ERROR
tests/e2e/test_playwright_setup.py::test_playwright_setup SKIPPED (S...)

==================================== ERRORS ====================================
_______ ERROR at setup of test_delete_testing_range_page_loads[chromium] _______

fixturedef = <FixtureDef argname='playwright' scope='session' baseid=''>
request = <SubRequest 'playwright' for <Function test_delete_testing_range_page_loads[chromium]>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_asyncio/plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: in playwright
    pw = sync_playwright().start()
         ^^^^^^^^^^^^^^^^^^^^^^^^^
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
______________ ERROR at setup of test_min_max_id_inputs[chromium] ______________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
________ ERROR at setup of test_dry_run_checkbox_and_preview[chromium] _________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
________ ERROR at setup of test_delete_button_and_real_delete[chromium] ________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
____________ ERROR at setup of test_diagnostics_messaging[chromium] ____________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
______ ERROR at setup of TestExcelUpload.test_upload_page_loads[chromium] ______

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
______ ERROR at setup of TestExcelUpload.test_file_input_exists[chromium] ______

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
______ ERROR at setup of TestExcelUpload.test_drop_zone_exists[chromium] _______

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of TestExcelUpload.test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_____ ERROR at setup of TestExcelUpload.test_invalid_file_upload[chromium] _____

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
______ ERROR at setup of TestExcelUpload.test_empty_file_upload[chromium] ______

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
______ ERROR at setup of TestExcelUpload.test_large_file_upload[chromium] ______

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
____ ERROR at setup of TestUploadPageElements.test_page_structure[chromium] ____

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
____ ERROR at setup of TestUploadPageElements.test_form_structure[chromium] ____

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of TestUploadPageElements.test_accessibility_features[chromium] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_______ ERROR at setup of test_list_staged_diagnostics_overlay[chromium] _______

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
______________ ERROR at setup of test_upload_file_only[chromium] _______________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
__________ ERROR at setup of test_discard_staged_file_only[chromium] ___________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_________ ERROR at setup of test_upload_multiple_files_only[chromium] __________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_____ ERROR at setup of test_discard_each_staged_file_separately[chromium] _____

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_________ ERROR at setup of test_upload_malformed_file_only[chromium] __________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_________ ERROR at setup of test_discard_malformed_file_only[chromium] _________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_________ ERROR at setup of test_feedback_updates_page_loads[chromium] _________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
____ ERROR at setup of test_feedback_updates_filter_functionality[chromium] ____

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
____ ERROR at setup of test_feedback_updates_download_csv_button[chromium] _____

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_______ ERROR at setup of test_feedback_updates_accessibility[chromium] ________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
________ ERROR at setup of test_feedback_updates_empty_state[chromium] _________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_____ ERROR at setup of test_feedback_updates_long_text_overflow[chromium] _____

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_____ ERROR at setup of test_feedback_updates_special_characters[chromium] _____

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
___ ERROR at setup of test_feedback_updates_date_range_boundaries[chromium] ____

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_feedback_updates_csv_download_with_filters[chromium] __

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
____ ERROR at setup of test_feedback_updates_rapid_filter_changes[chromium] ____

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_______ ERROR at setup of test_feedback_updates_large_data_set[chromium] _______

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_______________ ERROR at setup of test_homepage_loads[chromium] ________________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
____________ ERROR at setup of test_homepage_empty_state[chromium] _____________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
__________ ERROR at setup of test_homepage_navigation_menu[chromium] ___________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
___________ ERROR at setup of test_homepage_accessibility[chromium] ____________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_______ ERROR at setup of test_homepage_card_content_and_links[chromium] _______

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
__________ ERROR at setup of test_homepage_card_navigation[chromium] ___________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
______ ERROR at setup of test_homepage_pagination_or_scrolling[chromium] _______

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
__ ERROR at setup of test_homepage_special_characters_and_long_text[chromium] __

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_diagnostics_overlay_on_diagnostic_test_page[chromium] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
___________ ERROR at setup of test_list_uploads_page_loads[chromium] ___________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
___________ ERROR at setup of test_list_uploads_file_links[chromium] ___________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_________ ERROR at setup of test_list_uploads_accessibility[chromium] __________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
__________ ERROR at setup of test_list_uploads_empty_state[chromium] ___________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
___________ ERROR at setup of test_calsmp_help_menu_links[chromium] ____________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_developer_utilities_menu_links_and_create_incidence[chromium] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
____________ ERROR at setup of test_hide_changes_checkbox[chromium] ____________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_____________ ERROR at setup of test_field_search_filter[chromium] _____________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_____________ ERROR at setup of test_change_summary_card[chromium] _____________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
___________ ERROR at setup of test_cancel_and_save_buttons[chromium] ___________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_____________ ERROR at setup of test_confirm_checkboxes[chromium] ______________

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_incremental_upload[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of TestExcelUpload.test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_02_bad_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_02_bad_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_incremental_upload[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of TestExcelUpload.test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_03_blank.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_03_blank.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_incremental_upload[chromium-feedback_forms/testing_versions/standard/generic_operator_feedback_v002_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of TestExcelUpload.test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_incremental_upload[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v070_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of TestExcelUpload.test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_01_good_data_update.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_01_good_data_update.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_incremental_upload[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v071_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of TestExcelUpload.test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_02_bad_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_02_bad_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_incremental_upload[chromium-feedback_forms/testing_versions/standard/oil_and_gas_operator_feedback_v070_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of TestExcelUpload.test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/generic_operator_feedback_v002_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/generic_operator_feedback_v002_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of TestExcelUpload.test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/generic_operator_feedback_v002_test_02_bad_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/generic_operator_feedback_v002_test_02_bad_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of TestExcelUpload.test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v070_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v070_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of TestExcelUpload.test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v070_test_02_bad_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v070_test_02_bad_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of TestExcelUpload.test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v071_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v071_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of TestExcelUpload.test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v071_test_02_bad_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v071_test_02_bad_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of TestExcelUpload.test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/oil_and_gas_operator_feedback_v070_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/oil_and_gas_operator_feedback_v070_test_01_good_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of TestExcelUpload.test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/oil_and_gas_operator_feedback_v070_test_02_bad_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
_ ERROR at setup of test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/oil_and_gas_operator_feedback_v070_test_02_bad_data.xlsx] _

    @pytest.fixture(scope="session")
    def playwright() -> Generator[Playwright, None, None]:
>       pw = sync_playwright().start()
             ^^^^^^^^^^^^^^^^^^^^^^^^^

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/pytest_playwright/pytest_playwright.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:84: in start
    return self.__enter__()
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <playwright.sync_api._context_manager.PlaywrightContextManager object at 0x7fea0d652f90>

        def __enter__(self) -> SyncPlaywright:
            try:
                self._loop = asyncio.get_running_loop()
            except RuntimeError:
                self._loop = asyncio.new_event_loop()
                self._own_loop = True
            if self._loop.is_running():
                raise Error(
                    """It looks like you are using Playwright Sync API inside the asyncio loop.
    Please use the Async API instead."""
                )
    
            # Create a new fiber for the protocol dispatcher. It will be pumping events
            # until the end of times. We will pass control to that fiber every time we
            # block while waiting for a response.
            def greenlet_main() -> None:
                self._loop.run_until_complete(self._connection.run_as_sync())
    
            dispatcher_fiber = MainGreenlet(greenlet_main)
    
            self._connection = Connection(
                dispatcher_fiber,
                create_remote_object,
                PipeTransport(self._loop),
                self._loop,
            )
    
            g_self = greenlet.getcurrent()
    
            def callback_wrapper(channel_owner: ChannelOwner) -> None:
                playwright_impl = cast(Playwright, channel_owner)
                self._playwright = SyncPlaywright(playwright_impl)
                g_self.switch()
    
            # Switch control to the dispatcher, it'll fire an event and pass control to
            # the calling greenlet.
            self._connection.call_on_object_with_known_name("Playwright", callback_wrapper)
            dispatcher_fiber.switch()
    
>           playwright = self._playwright
                         ^^^^^^^^^^^^^^^^
E           AttributeError: 'PlaywrightContextManager' object has no attribute '_playwright'

../../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/sync_api/_context_manager.py:79: AttributeError
=========================== short test summary info ============================
ERROR tests/e2e/test_delete_testing_data.py::test_delete_testing_range_page_loads[chromium]
ERROR tests/e2e/test_delete_testing_data.py::test_min_max_id_inputs[chromium]
ERROR tests/e2e/test_delete_testing_data.py::test_dry_run_checkbox_and_preview[chromium]
ERROR tests/e2e/test_delete_testing_data.py::test_delete_button_and_real_delete[chromium]
ERROR tests/e2e/test_delete_testing_data.py::test_diagnostics_messaging[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_upload_page_loads[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_input_exists[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_drop_zone_exists[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_invalid_file_upload[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_empty_file_upload[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_large_file_upload[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::TestUploadPageElements::test_page_structure[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::TestUploadPageElements::test_form_structure[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::TestUploadPageElements::test_accessibility_features[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::test_list_staged_diagnostics_overlay[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::test_upload_file_only[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::test_discard_staged_file_only[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::test_upload_multiple_files_only[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::test_discard_each_staged_file_separately[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::test_upload_malformed_file_only[chromium]
ERROR tests/e2e/test_excel_upload_workflows.py::test_discard_malformed_file_only[chromium]
ERROR tests/e2e/test_feedback_updates.py::test_feedback_updates_page_loads[chromium]
ERROR tests/e2e/test_feedback_updates.py::test_feedback_updates_filter_functionality[chromium]
ERROR tests/e2e/test_feedback_updates.py::test_feedback_updates_download_csv_button[chromium]
ERROR tests/e2e/test_feedback_updates.py::test_feedback_updates_accessibility[chromium]
ERROR tests/e2e/test_feedback_updates.py::test_feedback_updates_empty_state[chromium]
ERROR tests/e2e/test_feedback_updates.py::test_feedback_updates_long_text_overflow[chromium]
ERROR tests/e2e/test_feedback_updates.py::test_feedback_updates_special_characters[chromium]
ERROR tests/e2e/test_feedback_updates.py::test_feedback_updates_date_range_boundaries[chromium]
ERROR tests/e2e/test_feedback_updates.py::test_feedback_updates_csv_download_with_filters[chromium]
ERROR tests/e2e/test_feedback_updates.py::test_feedback_updates_rapid_filter_changes[chromium]
ERROR tests/e2e/test_feedback_updates.py::test_feedback_updates_large_data_set[chromium]
ERROR tests/e2e/test_homepage.py::test_homepage_loads[chromium] - AttributeEr...
ERROR tests/e2e/test_homepage.py::test_homepage_empty_state[chromium] - Attri...
ERROR tests/e2e/test_homepage.py::test_homepage_navigation_menu[chromium] - A...
ERROR tests/e2e/test_homepage.py::test_homepage_accessibility[chromium] - Att...
ERROR tests/e2e/test_homepage.py::test_homepage_card_content_and_links[chromium]
ERROR tests/e2e/test_homepage.py::test_homepage_card_navigation[chromium] - A...
ERROR tests/e2e/test_homepage.py::test_homepage_pagination_or_scrolling[chromium]
ERROR tests/e2e/test_homepage.py::test_homepage_special_characters_and_long_text[chromium]
ERROR tests/e2e/test_javascript_logging.py::test_diagnostics_overlay_on_diagnostic_test_page[chromium]
ERROR tests/e2e/test_list_uploads.py::test_list_uploads_page_loads[chromium]
ERROR tests/e2e/test_list_uploads.py::test_list_uploads_file_links[chromium]
ERROR tests/e2e/test_list_uploads.py::test_list_uploads_accessibility[chromium]
ERROR tests/e2e/test_list_uploads.py::test_list_uploads_empty_state[chromium]
ERROR tests/e2e/test_menu_calsmp_help.py::test_calsmp_help_menu_links[chromium]
ERROR tests/e2e/test_menu_developer_utilities.py::test_developer_utilities_menu_links_and_create_incidence[chromium]
ERROR tests/e2e/test_review_staged.py::test_hide_changes_checkbox[chromium]
ERROR tests/e2e/test_review_staged.py::test_field_search_filter[chromium] - A...
ERROR tests/e2e/test_review_staged.py::test_change_summary_card[chromium] - A...
ERROR tests/e2e/test_review_staged.py::test_cancel_and_save_buttons[chromium]
ERROR tests/e2e/test_review_staged.py::test_confirm_checkboxes[chromium] - At...
ERROR tests/e2e/test_review_staged.py::test_incremental_upload[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_02_bad_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_02_bad_data.xlsx]
ERROR tests/e2e/test_review_staged.py::test_incremental_upload[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_03_blank.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/dairy_digester_operator_feedback_v006_test_03_blank.xlsx]
ERROR tests/e2e/test_review_staged.py::test_incremental_upload[chromium-feedback_forms/testing_versions/standard/generic_operator_feedback_v002_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_01_good_data.xlsx]Task exception was never retrieved
future: <Task finished name='Task-3' coro=<Connection.run.<locals>.init() done, defined at /home/theld/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/_impl/_connection.py:307> exception=Exception('Connection.init: Connection closed while reading from the driver')>
Traceback (most recent call last):
  File "/home/theld/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/_impl/_connection.py", line 308, in init
    self.playwright_future.set_result(await self._root_object.initialize())
                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/theld/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/_impl/_connection.py", line 249, in initialize
    await self._channel.send(
  File "/home/theld/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/_impl/_connection.py", line 69, in send
    return await self._connection.wrap_api_call(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/theld/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/playwright/_impl/_connection.py", line 558, in wrap_api_call
    raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
Exception: Connection.init: Connection closed while reading from the driver

ERROR tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_01_good_data.xlsx]
ERROR tests/e2e/test_review_staged.py::test_incremental_upload[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v070_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_01_good_data_update.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_01_good_data_update.xlsx]
ERROR tests/e2e/test_review_staged.py::test_incremental_upload[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v071_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_02_bad_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/energy_operator_feedback_v003_test_02_bad_data.xlsx]
ERROR tests/e2e/test_review_staged.py::test_incremental_upload[chromium-feedback_forms/testing_versions/standard/oil_and_gas_operator_feedback_v070_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/generic_operator_feedback_v002_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/generic_operator_feedback_v002_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/generic_operator_feedback_v002_test_02_bad_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/generic_operator_feedback_v002_test_02_bad_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v070_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v070_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v070_test_02_bad_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v070_test_02_bad_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v071_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v071_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v071_test_02_bad_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/landfill_operator_feedback_v071_test_02_bad_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/oil_and_gas_operator_feedback_v070_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/oil_and_gas_operator_feedback_v070_test_01_good_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::TestExcelUpload::test_file_upload_workflow[chromium-feedback_forms/testing_versions/standard/oil_and_gas_operator_feedback_v070_test_02_bad_data.xlsx]
ERROR tests/e2e/test_excel_upload_workflows.py::test_excel_upload_deep_backend_validation[chromium-feedback_forms/testing_versions/standard/oil_and_gas_operator_feedback_v070_test_02_bad_data.xlsx]
======================== 1 skipped, 86 errors in 1.72s =========================
