============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0 -- /home/tonyh/miniconda3/envs/mini_conda_02/bin/python
cachedir: .pytest_cache
rootdir: /home/tonyh/git_repos/feedback_portal
configfile: pytest.ini
plugins: base-url-2.1.0, anyio-4.7.0, playwright-0.7.0, asyncio-1.1.0
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 22 items

tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_route_function_signature PASSED
tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_get_request FAILED
tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_success PASSED
tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_missing_id_error FAILED
tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_conversion_error FAILED
tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_file_error FAILED
tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_database_error FAILED
tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_unknown_error FAILED
tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_no_file_selected FAILED
tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_with_message_parameter FAILED
tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_exception_handling FAILED
tests/arb/portal/test_routes.py::test_upload_file_refactored_route_function_signature PASSED
tests/arb/portal/test_routes.py::test_upload_file_refactored_get_request FAILED
tests/arb/portal/test_routes.py::test_upload_file_refactored_success PASSED
tests/arb/portal/test_routes.py::test_upload_file_refactored_missing_id_error FAILED
tests/arb/portal/test_routes.py::test_upload_file_refactored_conversion_error FAILED
tests/arb/portal/test_routes.py::test_upload_file_refactored_file_error FAILED
tests/arb/portal/test_routes.py::test_upload_file_refactored_database_error FAILED
tests/arb/portal/test_routes.py::test_upload_file_refactored_unknown_error FAILED
tests/arb/portal/test_routes.py::test_upload_file_refactored_no_file_selected FAILED
tests/arb/portal/test_routes.py::test_upload_file_refactored_with_message_parameter FAILED
tests/arb/portal/test_routes.py::test_upload_file_refactored_exception_handling FAILED

=================================== FAILURES ===================================
________________ test_upload_file_staged_refactored_get_request ________________

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_staged_refactored_get_request(client):
      """upload_file_staged_refactored GET request returns upload form."""
>     response = client.get('/upload_staged_refactored')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:1577: in upload_file_staged_refactored
    return render_upload_page(form, message, 'upload_staged.html', "staged")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/utils/route_upload_helpers.py:284: in render_upload_page
    return render_template(template_name, **template_context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload_staged.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca688c890>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
------------------------------ Captured log setup ------------------------------
DEBUG    arb.portal.startup.flask:flask.py:109 Flask Jinja2 globals and logging initialized.
WARNING  arb.utils.sql_alchemy:sql_alchemy.py:214 coordinates is of type: Geometry that is not implemented in python.  Setting python type to None.
WARNING  arb.utils.sql_alchemy:sql_alchemy.py:215 
WARNING  arb.utils.sql_alchemy:sql_alchemy.py:214 geometry is of type: Geometry that is not implemented in python.  Setting python type to None.
WARNING  arb.utils.sql_alchemy:sql_alchemy.py:215 
WARNING  arb.utils.sql_alchemy:sql_alchemy.py:214 origin is of type: Geometry that is not implemented in python.  Setting python type to None.
WARNING  arb.utils.sql_alchemy:sql_alchemy.py:215 
WARNING  arb.utils.sql_alchemy:sql_alchemy.py:214 extent is of type: Geometry that is not implemented in python.  Setting python type to None.
WARNING  arb.utils.sql_alchemy:sql_alchemy.py:215 
WARNING  arb.utils.sql_alchemy:sql_alchemy.py:214 footprint is of type: Geometry that is not implemented in python.  Setting python type to None.
WARNING  arb.utils.sql_alchemy:sql_alchemy.py:215
_____________ test_upload_file_staged_refactored_missing_id_error ______________

message = None

    @main.route('/upload_staged_refactored', methods=['GET', 'POST'])
    @main.route('/upload_staged_refactored/<message>', methods=['GET', 'POST'])
    def upload_file_staged_refactored(message: str | None = None) -> Union[str, Response]:
      """
      Refactored version of upload_file_staged with improved error handling.
    
      This route demonstrates the new staging approach using StagingResult named tuples
      for better error handling and user experience. It provides the same functionality
      as upload_file_staged but with more specific error messages and clearer logic.
    
      Args:
          message (str | None): Optional message to display on the staged upload page.
    
      Returns:
          str|Response: Rendered HTML for the staged upload form, or redirect after upload.
    
      Examples:
          # In browser: GET /upload_staged_refactored
          # Returns: HTML staged upload form
          # In browser: POST /upload_staged_refactored
          # Redirects to: /list_staged or shows specific error message
    
      Notes:
          - This is a parallel implementation to upload_file_staged
          - Uses the new stage_uploaded_file_for_review function
          - Provides more specific error messages based on error_type
          - Maintains the same user workflow as the original route
      """
      logger.info(f"route called: upload_file_staged_refactored with message: {message}")
    
      base: AutomapBase = current_app.base  # type: ignore[attr-defined]
      form = UploadForm()
    
      # Decode optional redirect message
      if message:
        message = unquote(message)
        logger.debug(f"Received redirect message: {message}")
    
      upload_folder = get_upload_folder()
      logger.debug(f"Request received with files: {list(request.files.keys())}, upload_folder={upload_folder}")
    
      if request.method == 'POST':
        flash("_upload_attempted", "internal-marker")
    
        try:
          request_file = request.files.get('file')
    
          # Validate upload request using shared helper
          is_valid, error_message = validate_upload_request(request_file)
          if not is_valid:
            return render_upload_error_page(form, error_message, 'upload_staged.html', "staged")
    
          logger.debug(f"Received uploaded file: {request_file.filename}")
    
          # Save and stage (no DB commit) using the new refactored function
          result = stage_uploaded_file_for_review(db, upload_folder, request_file, base)
    
          if result.success:
            logger.debug(
              f"Staged upload successful: id={result.id_}, sector={result.sector}, filename={result.staged_filename}. Redirecting to review page.")
            # Enhanced success feedback with staging details
            success_message = (
              f"✅ File '{request_file.filename}' staged successfully!\n"
              f"📋 ID: {result.id_}\n"
              f"🏭 Sector: {result.sector}\n"
              f"📁 Staged as: {result.staged_filename}\n"
              f"🔍 Ready for review and confirmation."
            )
            flash(success_message, "success")
            return redirect(url_for('main.review_staged', id_=result.id_, filename=result.staged_filename))
    
          # Handle specific error types based on the result
          if result.error_type == "missing_id":
            logger.warning(f"Staging blocked: missing or invalid id_incidence in {result.file_path.name}")
>           return render_template(
              'upload_staged.html',
              form=form,
              upload_message=(
                "This file is missing a valid 'Incidence/Emission ID' (id_incidence). "
                "Please add a positive integer id_incidence to your spreadsheet before uploading."
              )

source/production/arb/portal/routes.py:1523: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload_staged.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca617ce90>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_staged_refactored_missing_id_error(client):
      """upload_file_staged_refactored handles missing ID error."""
      # Mock the staging function to return missing ID error
      with patch('arb.portal.routes.stage_uploaded_file_for_review') as mock_stage:
        mock_stage.return_value = StagingResult(
          file_path=Path("uploads/test.xlsx"),
          id_=None,
          sector="Dairy Digester",
          json_data={"sector": "Dairy Digester"},
          staged_filename=None,
          success=False,
          error_message="No valid 'Incidence/Emission ID' found in spreadsheet",
          error_type="missing_id"
        )
    
        # Create a mock file upload
        data = {'file': (io.BytesIO(b'test file content'), 'test.xlsx')}
>       response = client.post('/upload_staged_refactored', data=data, content_type='multipart/form-data')
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:1570: in upload_file_staged_refactored
    return render_template(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload_staged.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca617ce90>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
------------------------------ Captured log call -------------------------------
WARNING  arb.portal.routes:routes.py:1522 Staging blocked: missing or invalid id_incidence in test.xlsx
ERROR    arb.portal.routes:routes.py:1548 Exception occurred during staged upload.
Traceback (most recent call last):
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/routes.py", line 1523, in upload_file_staged_refactored
    return render_template(
           ^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 150, in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 131, in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 1295, in render
    self.environment.handle_exception()
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 942, in handle_exception
    raise rewrite_traceback_stack(source=source)
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/upload_staged.html", line 1, in top-level template code
    {% extends 'base.html' %}
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/base.html", line 42, in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/includes/navbar.jinja", line 100, in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1121, in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1110, in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py", line 924, in build
    raise BuildError(endpoint, values, method, self)
werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?
_____________ test_upload_file_staged_refactored_conversion_error ______________

message = None

    @main.route('/upload_staged_refactored', methods=['GET', 'POST'])
    @main.route('/upload_staged_refactored/<message>', methods=['GET', 'POST'])
    def upload_file_staged_refactored(message: str | None = None) -> Union[str, Response]:
      """
      Refactored version of upload_file_staged with improved error handling.
    
      This route demonstrates the new staging approach using StagingResult named tuples
      for better error handling and user experience. It provides the same functionality
      as upload_file_staged but with more specific error messages and clearer logic.
    
      Args:
          message (str | None): Optional message to display on the staged upload page.
    
      Returns:
          str|Response: Rendered HTML for the staged upload form, or redirect after upload.
    
      Examples:
          # In browser: GET /upload_staged_refactored
          # Returns: HTML staged upload form
          # In browser: POST /upload_staged_refactored
          # Redirects to: /list_staged or shows specific error message
    
      Notes:
          - This is a parallel implementation to upload_file_staged
          - Uses the new stage_uploaded_file_for_review function
          - Provides more specific error messages based on error_type
          - Maintains the same user workflow as the original route
      """
      logger.info(f"route called: upload_file_staged_refactored with message: {message}")
    
      base: AutomapBase = current_app.base  # type: ignore[attr-defined]
      form = UploadForm()
    
      # Decode optional redirect message
      if message:
        message = unquote(message)
        logger.debug(f"Received redirect message: {message}")
    
      upload_folder = get_upload_folder()
      logger.debug(f"Request received with files: {list(request.files.keys())}, upload_folder={upload_folder}")
    
      if request.method == 'POST':
        flash("_upload_attempted", "internal-marker")
    
        try:
          request_file = request.files.get('file')
    
          # Validate upload request using shared helper
          is_valid, error_message = validate_upload_request(request_file)
          if not is_valid:
            return render_upload_error_page(form, error_message, 'upload_staged.html', "staged")
    
          logger.debug(f"Received uploaded file: {request_file.filename}")
    
          # Save and stage (no DB commit) using the new refactored function
          result = stage_uploaded_file_for_review(db, upload_folder, request_file, base)
    
          if result.success:
            logger.debug(
              f"Staged upload successful: id={result.id_}, sector={result.sector}, filename={result.staged_filename}. Redirecting to review page.")
            # Enhanced success feedback with staging details
            success_message = (
              f"✅ File '{request_file.filename}' staged successfully!\n"
              f"📋 ID: {result.id_}\n"
              f"🏭 Sector: {result.sector}\n"
              f"📁 Staged as: {result.staged_filename}\n"
              f"🔍 Ready for review and confirmation."
            )
            flash(success_message, "success")
            return redirect(url_for('main.review_staged', id_=result.id_, filename=result.staged_filename))
    
          # Handle specific error types based on the result
          if result.error_type == "missing_id":
            logger.warning(f"Staging blocked: missing or invalid id_incidence in {result.file_path.name}")
            return render_template(
              'upload_staged.html',
              form=form,
              upload_message=(
                "This file is missing a valid 'Incidence/Emission ID' (id_incidence). "
                "Please add a positive integer id_incidence to your spreadsheet before uploading."
              )
            )
          elif result.error_type == "conversion_failed":
            logger.warning(f"Staging failed file conversion: {result.file_path=}")
>           return render_template(
              'upload_staged.html',
              form=form,
              upload_message=result.error_message or "Uploaded file format not recognized."
            )

source/production/arb/portal/routes.py:1533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload_staged.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca6320810>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_staged_refactored_conversion_error(client):
      """upload_file_staged_refactored handles conversion error."""
      # Mock the staging function to return conversion error
      with patch('arb.portal.routes.stage_uploaded_file_for_review') as mock_stage:
        mock_stage.return_value = StagingResult(
          file_path=Path("uploads/test.txt"),
          id_=None,
          sector=None,
          json_data={},
          staged_filename=None,
          success=False,
          error_message="Unsupported file format. Please upload Excel (.xlsx) file.",
          error_type="conversion_failed"
        )
    
        # Create a mock file upload
        data = {'file': (io.BytesIO(b'test file content'), 'test.txt')}
>       response = client.post('/upload_staged_refactored', data=data, content_type='multipart/form-data')
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:1570: in upload_file_staged_refactored
    return render_template(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload_staged.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca6320810>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
------------------------------ Captured log call -------------------------------
WARNING  arb.portal.routes:routes.py:1532 Staging failed file conversion: result.file_path=PosixPath('uploads/test.txt')
ERROR    arb.portal.routes:routes.py:1548 Exception occurred during staged upload.
Traceback (most recent call last):
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/routes.py", line 1533, in upload_file_staged_refactored
    return render_template(
           ^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 150, in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 131, in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 1295, in render
    self.environment.handle_exception()
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 942, in handle_exception
    raise rewrite_traceback_stack(source=source)
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/upload_staged.html", line 1, in top-level template code
    {% extends 'base.html' %}
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/base.html", line 42, in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/includes/navbar.jinja", line 100, in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1121, in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1110, in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py", line 924, in build
    raise BuildError(endpoint, values, method, self)
werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?
________________ test_upload_file_staged_refactored_file_error _________________

message = None

    @main.route('/upload_staged_refactored', methods=['GET', 'POST'])
    @main.route('/upload_staged_refactored/<message>', methods=['GET', 'POST'])
    def upload_file_staged_refactored(message: str | None = None) -> Union[str, Response]:
      """
      Refactored version of upload_file_staged with improved error handling.
    
      This route demonstrates the new staging approach using StagingResult named tuples
      for better error handling and user experience. It provides the same functionality
      as upload_file_staged but with more specific error messages and clearer logic.
    
      Args:
          message (str | None): Optional message to display on the staged upload page.
    
      Returns:
          str|Response: Rendered HTML for the staged upload form, or redirect after upload.
    
      Examples:
          # In browser: GET /upload_staged_refactored
          # Returns: HTML staged upload form
          # In browser: POST /upload_staged_refactored
          # Redirects to: /list_staged or shows specific error message
    
      Notes:
          - This is a parallel implementation to upload_file_staged
          - Uses the new stage_uploaded_file_for_review function
          - Provides more specific error messages based on error_type
          - Maintains the same user workflow as the original route
      """
      logger.info(f"route called: upload_file_staged_refactored with message: {message}")
    
      base: AutomapBase = current_app.base  # type: ignore[attr-defined]
      form = UploadForm()
    
      # Decode optional redirect message
      if message:
        message = unquote(message)
        logger.debug(f"Received redirect message: {message}")
    
      upload_folder = get_upload_folder()
      logger.debug(f"Request received with files: {list(request.files.keys())}, upload_folder={upload_folder}")
    
      if request.method == 'POST':
        flash("_upload_attempted", "internal-marker")
    
        try:
          request_file = request.files.get('file')
    
          # Validate upload request using shared helper
          is_valid, error_message = validate_upload_request(request_file)
          if not is_valid:
            return render_upload_error_page(form, error_message, 'upload_staged.html', "staged")
    
          logger.debug(f"Received uploaded file: {request_file.filename}")
    
          # Save and stage (no DB commit) using the new refactored function
          result = stage_uploaded_file_for_review(db, upload_folder, request_file, base)
    
          if result.success:
            logger.debug(
              f"Staged upload successful: id={result.id_}, sector={result.sector}, filename={result.staged_filename}. Redirecting to review page.")
            # Enhanced success feedback with staging details
            success_message = (
              f"✅ File '{request_file.filename}' staged successfully!\n"
              f"📋 ID: {result.id_}\n"
              f"🏭 Sector: {result.sector}\n"
              f"📁 Staged as: {result.staged_filename}\n"
              f"🔍 Ready for review and confirmation."
            )
            flash(success_message, "success")
            return redirect(url_for('main.review_staged', id_=result.id_, filename=result.staged_filename))
    
          # Handle specific error types based on the result
          if result.error_type == "missing_id":
            logger.warning(f"Staging blocked: missing or invalid id_incidence in {result.file_path.name}")
            return render_template(
              'upload_staged.html',
              form=form,
              upload_message=(
                "This file is missing a valid 'Incidence/Emission ID' (id_incidence). "
                "Please add a positive integer id_incidence to your spreadsheet before uploading."
              )
            )
          elif result.error_type == "conversion_failed":
            logger.warning(f"Staging failed file conversion: {result.file_path=}")
            return render_template(
              'upload_staged.html',
              form=form,
              upload_message=result.error_message or "Uploaded file format not recognized."
            )
          else:
            # Handle other error types
            logger.warning(f"Staging failed: {result.error_type=}, {result.error_message=}")
>           return render_template(
              'upload_staged.html',
              form=form,
              upload_message=result.error_message or "Staging processing failed."
            )

source/production/arb/portal/routes.py:1541: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload_staged.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca5dcd050>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_staged_refactored_file_error(client):
      """upload_file_staged_refactored handles file error."""
      # Mock the staging function to return file error
      with patch('arb.portal.routes.stage_uploaded_file_for_review') as mock_stage:
        mock_stage.return_value = StagingResult(
          file_path=Path("uploads/test.xlsx"),
          id_=None,
          sector=None,
          json_data={},
          staged_filename=None,
          success=False,
          error_message="Failed to save uploaded file",
          error_type="file_error"
        )
    
        # Create a mock file upload
        data = {'file': (io.BytesIO(b'test file content'), 'test.xlsx')}
>       response = client.post('/upload_staged_refactored', data=data, content_type='multipart/form-data')
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:1570: in upload_file_staged_refactored
    return render_template(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload_staged.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca5dcd050>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
------------------------------ Captured log call -------------------------------
WARNING  arb.portal.routes:routes.py:1540 Staging failed: result.error_type='file_error', result.error_message='Failed to save uploaded file'
ERROR    arb.portal.routes:routes.py:1548 Exception occurred during staged upload.
Traceback (most recent call last):
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/routes.py", line 1541, in upload_file_staged_refactored
    return render_template(
           ^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 150, in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 131, in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 1295, in render
    self.environment.handle_exception()
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 942, in handle_exception
    raise rewrite_traceback_stack(source=source)
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/upload_staged.html", line 1, in top-level template code
    {% extends 'base.html' %}
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/base.html", line 42, in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/includes/navbar.jinja", line 100, in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1121, in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1110, in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py", line 924, in build
    raise BuildError(endpoint, values, method, self)
werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?
______________ test_upload_file_staged_refactored_database_error _______________

message = None

    @main.route('/upload_staged_refactored', methods=['GET', 'POST'])
    @main.route('/upload_staged_refactored/<message>', methods=['GET', 'POST'])
    def upload_file_staged_refactored(message: str | None = None) -> Union[str, Response]:
      """
      Refactored version of upload_file_staged with improved error handling.
    
      This route demonstrates the new staging approach using StagingResult named tuples
      for better error handling and user experience. It provides the same functionality
      as upload_file_staged but with more specific error messages and clearer logic.
    
      Args:
          message (str | None): Optional message to display on the staged upload page.
    
      Returns:
          str|Response: Rendered HTML for the staged upload form, or redirect after upload.
    
      Examples:
          # In browser: GET /upload_staged_refactored
          # Returns: HTML staged upload form
          # In browser: POST /upload_staged_refactored
          # Redirects to: /list_staged or shows specific error message
    
      Notes:
          - This is a parallel implementation to upload_file_staged
          - Uses the new stage_uploaded_file_for_review function
          - Provides more specific error messages based on error_type
          - Maintains the same user workflow as the original route
      """
      logger.info(f"route called: upload_file_staged_refactored with message: {message}")
    
      base: AutomapBase = current_app.base  # type: ignore[attr-defined]
      form = UploadForm()
    
      # Decode optional redirect message
      if message:
        message = unquote(message)
        logger.debug(f"Received redirect message: {message}")
    
      upload_folder = get_upload_folder()
      logger.debug(f"Request received with files: {list(request.files.keys())}, upload_folder={upload_folder}")
    
      if request.method == 'POST':
        flash("_upload_attempted", "internal-marker")
    
        try:
          request_file = request.files.get('file')
    
          # Validate upload request using shared helper
          is_valid, error_message = validate_upload_request(request_file)
          if not is_valid:
            return render_upload_error_page(form, error_message, 'upload_staged.html', "staged")
    
          logger.debug(f"Received uploaded file: {request_file.filename}")
    
          # Save and stage (no DB commit) using the new refactored function
          result = stage_uploaded_file_for_review(db, upload_folder, request_file, base)
    
          if result.success:
            logger.debug(
              f"Staged upload successful: id={result.id_}, sector={result.sector}, filename={result.staged_filename}. Redirecting to review page.")
            # Enhanced success feedback with staging details
            success_message = (
              f"✅ File '{request_file.filename}' staged successfully!\n"
              f"📋 ID: {result.id_}\n"
              f"🏭 Sector: {result.sector}\n"
              f"📁 Staged as: {result.staged_filename}\n"
              f"🔍 Ready for review and confirmation."
            )
            flash(success_message, "success")
            return redirect(url_for('main.review_staged', id_=result.id_, filename=result.staged_filename))
    
          # Handle specific error types based on the result
          if result.error_type == "missing_id":
            logger.warning(f"Staging blocked: missing or invalid id_incidence in {result.file_path.name}")
            return render_template(
              'upload_staged.html',
              form=form,
              upload_message=(
                "This file is missing a valid 'Incidence/Emission ID' (id_incidence). "
                "Please add a positive integer id_incidence to your spreadsheet before uploading."
              )
            )
          elif result.error_type == "conversion_failed":
            logger.warning(f"Staging failed file conversion: {result.file_path=}")
            return render_template(
              'upload_staged.html',
              form=form,
              upload_message=result.error_message or "Uploaded file format not recognized."
            )
          else:
            # Handle other error types
            logger.warning(f"Staging failed: {result.error_type=}, {result.error_message=}")
>           return render_template(
              'upload_staged.html',
              form=form,
              upload_message=result.error_message or "Staging processing failed."
            )

source/production/arb/portal/routes.py:1541: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload_staged.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca640e8d0>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_staged_refactored_database_error(client):
      """upload_file_staged_refactored handles database error."""
      # Mock the staging function to return database error
      with patch('arb.portal.routes.stage_uploaded_file_for_review') as mock_stage:
        mock_stage.return_value = StagingResult(
          file_path=Path("uploads/test.xlsx"),
          id_=123,
          sector="Dairy Digester",
          json_data={"id_incidence": 123},
          staged_filename=None,
          success=False,
          error_message="Database connection failed",
          error_type="database_error"
        )
    
        # Create a mock file upload
        data = {'file': (io.BytesIO(b'test file content'), 'test.xlsx')}
>       response = client.post('/upload_staged_refactored', data=data, content_type='multipart/form-data')
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:1570: in upload_file_staged_refactored
    return render_template(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload_staged.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca640e8d0>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
------------------------------ Captured log call -------------------------------
WARNING  arb.portal.routes:routes.py:1540 Staging failed: result.error_type='database_error', result.error_message='Database connection failed'
ERROR    arb.portal.routes:routes.py:1548 Exception occurred during staged upload.
Traceback (most recent call last):
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/routes.py", line 1541, in upload_file_staged_refactored
    return render_template(
           ^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 150, in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 131, in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 1295, in render
    self.environment.handle_exception()
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 942, in handle_exception
    raise rewrite_traceback_stack(source=source)
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/upload_staged.html", line 1, in top-level template code
    {% extends 'base.html' %}
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/base.html", line 42, in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/includes/navbar.jinja", line 100, in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1121, in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1110, in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py", line 924, in build
    raise BuildError(endpoint, values, method, self)
werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?
_______________ test_upload_file_staged_refactored_unknown_error _______________

message = None

    @main.route('/upload_staged_refactored', methods=['GET', 'POST'])
    @main.route('/upload_staged_refactored/<message>', methods=['GET', 'POST'])
    def upload_file_staged_refactored(message: str | None = None) -> Union[str, Response]:
      """
      Refactored version of upload_file_staged with improved error handling.
    
      This route demonstrates the new staging approach using StagingResult named tuples
      for better error handling and user experience. It provides the same functionality
      as upload_file_staged but with more specific error messages and clearer logic.
    
      Args:
          message (str | None): Optional message to display on the staged upload page.
    
      Returns:
          str|Response: Rendered HTML for the staged upload form, or redirect after upload.
    
      Examples:
          # In browser: GET /upload_staged_refactored
          # Returns: HTML staged upload form
          # In browser: POST /upload_staged_refactored
          # Redirects to: /list_staged or shows specific error message
    
      Notes:
          - This is a parallel implementation to upload_file_staged
          - Uses the new stage_uploaded_file_for_review function
          - Provides more specific error messages based on error_type
          - Maintains the same user workflow as the original route
      """
      logger.info(f"route called: upload_file_staged_refactored with message: {message}")
    
      base: AutomapBase = current_app.base  # type: ignore[attr-defined]
      form = UploadForm()
    
      # Decode optional redirect message
      if message:
        message = unquote(message)
        logger.debug(f"Received redirect message: {message}")
    
      upload_folder = get_upload_folder()
      logger.debug(f"Request received with files: {list(request.files.keys())}, upload_folder={upload_folder}")
    
      if request.method == 'POST':
        flash("_upload_attempted", "internal-marker")
    
        try:
          request_file = request.files.get('file')
    
          # Validate upload request using shared helper
          is_valid, error_message = validate_upload_request(request_file)
          if not is_valid:
            return render_upload_error_page(form, error_message, 'upload_staged.html', "staged")
    
          logger.debug(f"Received uploaded file: {request_file.filename}")
    
          # Save and stage (no DB commit) using the new refactored function
          result = stage_uploaded_file_for_review(db, upload_folder, request_file, base)
    
          if result.success:
            logger.debug(
              f"Staged upload successful: id={result.id_}, sector={result.sector}, filename={result.staged_filename}. Redirecting to review page.")
            # Enhanced success feedback with staging details
            success_message = (
              f"✅ File '{request_file.filename}' staged successfully!\n"
              f"📋 ID: {result.id_}\n"
              f"🏭 Sector: {result.sector}\n"
              f"📁 Staged as: {result.staged_filename}\n"
              f"🔍 Ready for review and confirmation."
            )
            flash(success_message, "success")
            return redirect(url_for('main.review_staged', id_=result.id_, filename=result.staged_filename))
    
          # Handle specific error types based on the result
          if result.error_type == "missing_id":
            logger.warning(f"Staging blocked: missing or invalid id_incidence in {result.file_path.name}")
            return render_template(
              'upload_staged.html',
              form=form,
              upload_message=(
                "This file is missing a valid 'Incidence/Emission ID' (id_incidence). "
                "Please add a positive integer id_incidence to your spreadsheet before uploading."
              )
            )
          elif result.error_type == "conversion_failed":
            logger.warning(f"Staging failed file conversion: {result.file_path=}")
            return render_template(
              'upload_staged.html',
              form=form,
              upload_message=result.error_message or "Uploaded file format not recognized."
            )
          else:
            # Handle other error types
            logger.warning(f"Staging failed: {result.error_type=}, {result.error_message=}")
>           return render_template(
              'upload_staged.html',
              form=form,
              upload_message=result.error_message or "Staging processing failed."
            )

source/production/arb/portal/routes.py:1541: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload_staged.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca63590d0>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_staged_refactored_unknown_error(client):
      """upload_file_staged_refactored handles unknown error."""
      # Mock the staging function to return unknown error
      with patch('arb.portal.routes.stage_uploaded_file_for_review') as mock_stage:
        mock_stage.return_value = StagingResult(
          file_path=Path("uploads/test.xlsx"),
          id_=None,
          sector=None,
          json_data={},
          staged_filename=None,
          success=False,
                  error_message="Unexpected error occurred",
          error_type="unknown_error"
        )
    
        # Create a mock file upload
        data = {'file': (io.BytesIO(b'test file content'), 'test.xlsx')}
>       response = client.post('/upload_staged_refactored', data=data, content_type='multipart/form-data')
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:1570: in upload_file_staged_refactored
    return render_template(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload_staged.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca63590d0>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
------------------------------ Captured log call -------------------------------
WARNING  arb.portal.routes:routes.py:1540 Staging failed: result.error_type='unknown_error', result.error_message='Unexpected error occurred'
ERROR    arb.portal.routes:routes.py:1548 Exception occurred during staged upload.
Traceback (most recent call last):
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/routes.py", line 1541, in upload_file_staged_refactored
    return render_template(
           ^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 150, in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 131, in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 1295, in render
    self.environment.handle_exception()
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 942, in handle_exception
    raise rewrite_traceback_stack(source=source)
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/upload_staged.html", line 1, in top-level template code
    {% extends 'base.html' %}
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/base.html", line 42, in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/includes/navbar.jinja", line 100, in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1121, in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1110, in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py", line 924, in build
    raise BuildError(endpoint, values, method, self)
werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?
_____________ test_upload_file_staged_refactored_no_file_selected ______________

message = None

    @main.route('/upload_staged_refactored', methods=['GET', 'POST'])
    @main.route('/upload_staged_refactored/<message>', methods=['GET', 'POST'])
    def upload_file_staged_refactored(message: str | None = None) -> Union[str, Response]:
      """
      Refactored version of upload_file_staged with improved error handling.
    
      This route demonstrates the new staging approach using StagingResult named tuples
      for better error handling and user experience. It provides the same functionality
      as upload_file_staged but with more specific error messages and clearer logic.
    
      Args:
          message (str | None): Optional message to display on the staged upload page.
    
      Returns:
          str|Response: Rendered HTML for the staged upload form, or redirect after upload.
    
      Examples:
          # In browser: GET /upload_staged_refactored
          # Returns: HTML staged upload form
          # In browser: POST /upload_staged_refactored
          # Redirects to: /list_staged or shows specific error message
    
      Notes:
          - This is a parallel implementation to upload_file_staged
          - Uses the new stage_uploaded_file_for_review function
          - Provides more specific error messages based on error_type
          - Maintains the same user workflow as the original route
      """
      logger.info(f"route called: upload_file_staged_refactored with message: {message}")
    
      base: AutomapBase = current_app.base  # type: ignore[attr-defined]
      form = UploadForm()
    
      # Decode optional redirect message
      if message:
        message = unquote(message)
        logger.debug(f"Received redirect message: {message}")
    
      upload_folder = get_upload_folder()
      logger.debug(f"Request received with files: {list(request.files.keys())}, upload_folder={upload_folder}")
    
      if request.method == 'POST':
        flash("_upload_attempted", "internal-marker")
    
        try:
          request_file = request.files.get('file')
    
          # Validate upload request using shared helper
          is_valid, error_message = validate_upload_request(request_file)
          if not is_valid:
>           return render_upload_error_page(form, error_message, 'upload_staged.html', "staged")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

source/production/arb/portal/routes.py:1499: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
source/production/arb/portal/utils/route_upload_helpers.py:344: in render_upload_error_page
    return render_template(template_name, **template_context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload_staged.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca5f9c0d0>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_staged_refactored_no_file_selected(client):
      """upload_file_staged_refactored handles no file selected."""
>     response = client.post('/upload_staged_refactored')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:1570: in upload_file_staged_refactored
    return render_template(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload_staged.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca5f9c0d0>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
------------------------------ Captured log call -------------------------------
WARNING  arb.portal.utils.route_upload_helpers:route_upload_helpers.py:50 POST received with no file selected.
ERROR    arb.portal.routes:routes.py:1548 Exception occurred during staged upload.
Traceback (most recent call last):
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/routes.py", line 1499, in upload_file_staged_refactored
    return render_upload_error_page(form, error_message, 'upload_staged.html', "staged")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/utils/route_upload_helpers.py", line 344, in render_upload_error_page
    return render_template(template_name, **template_context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 150, in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 131, in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 1295, in render
    self.environment.handle_exception()
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 942, in handle_exception
    raise rewrite_traceback_stack(source=source)
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/upload_staged.html", line 1, in top-level template code
    {% extends 'base.html' %}
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/base.html", line 42, in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/includes/navbar.jinja", line 100, in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1121, in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1110, in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py", line 924, in build
    raise BuildError(endpoint, values, method, self)
werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?
__________ test_upload_file_staged_refactored_with_message_parameter ___________

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_staged_refactored_with_message_parameter(client):
      """upload_file_staged_refactored GET with message parameter returns form."""
      test_message = "Test%20staged%20message"
>     response = client.get(f'/upload_staged_refactored/{test_message}')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:1577: in upload_file_staged_refactored
    return render_upload_page(form, message, 'upload_staged.html', "staged")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/utils/route_upload_helpers.py:284: in render_upload_page
    return render_template(template_name, **template_context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload_staged.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca5f54b50>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
____________ test_upload_file_staged_refactored_exception_handling _____________

message = None

    @main.route('/upload_staged_refactored', methods=['GET', 'POST'])
    @main.route('/upload_staged_refactored/<message>', methods=['GET', 'POST'])
    def upload_file_staged_refactored(message: str | None = None) -> Union[str, Response]:
      """
      Refactored version of upload_file_staged with improved error handling.
    
      This route demonstrates the new staging approach using StagingResult named tuples
      for better error handling and user experience. It provides the same functionality
      as upload_file_staged but with more specific error messages and clearer logic.
    
      Args:
          message (str | None): Optional message to display on the staged upload page.
    
      Returns:
          str|Response: Rendered HTML for the staged upload form, or redirect after upload.
    
      Examples:
          # In browser: GET /upload_staged_refactored
          # Returns: HTML staged upload form
          # In browser: POST /upload_staged_refactored
          # Redirects to: /list_staged or shows specific error message
    
      Notes:
          - This is a parallel implementation to upload_file_staged
          - Uses the new stage_uploaded_file_for_review function
          - Provides more specific error messages based on error_type
          - Maintains the same user workflow as the original route
      """
      logger.info(f"route called: upload_file_staged_refactored with message: {message}")
    
      base: AutomapBase = current_app.base  # type: ignore[attr-defined]
      form = UploadForm()
    
      # Decode optional redirect message
      if message:
        message = unquote(message)
        logger.debug(f"Received redirect message: {message}")
    
      upload_folder = get_upload_folder()
      logger.debug(f"Request received with files: {list(request.files.keys())}, upload_folder={upload_folder}")
    
      if request.method == 'POST':
        flash("_upload_attempted", "internal-marker")
    
        try:
          request_file = request.files.get('file')
    
          # Validate upload request using shared helper
          is_valid, error_message = validate_upload_request(request_file)
          if not is_valid:
            return render_upload_error_page(form, error_message, 'upload_staged.html', "staged")
    
          logger.debug(f"Received uploaded file: {request_file.filename}")
    
          # Save and stage (no DB commit) using the new refactored function
>         result = stage_uploaded_file_for_review(db, upload_folder, request_file, base)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

source/production/arb/portal/routes.py:1504: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='stage_uploaded_file_for_review' id='133919862990160'>
args = (<SQLAlchemy>, PosixPath('/home/tonyh/git_repos/feedback_portal/portal_uploads'), <FileStorage: 'test.xlsx' ('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')>, <class 'sqlalchemy.ext.automap.Base'>)
kwargs = {}, effect = Exception('Test exception')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Test exception

../../miniconda3/envs/mini_conda_02/lib/python3.11/unittest/mock.py:1183: Exception

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_staged_refactored_exception_handling(client):
      """upload_file_staged_refactored handles exceptions gracefully."""
      # Mock the staging function to raise an exception
      with patch('arb.portal.routes.stage_uploaded_file_for_review') as mock_stage:
        mock_stage.side_effect = Exception("Test exception")
    
        # Create a mock file upload
        data = {'file': (io.BytesIO(b'test file content'), 'test.xlsx')}
>       response = client.post('/upload_staged_refactored', data=data, content_type='multipart/form-data')
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:1570: in upload_file_staged_refactored
    return render_template(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload_staged.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca5dc8910>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
------------------------------ Captured log call -------------------------------
ERROR    arb.portal.routes:routes.py:1548 Exception occurred during staged upload.
Traceback (most recent call last):
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/routes.py", line 1504, in upload_file_staged_refactored
    result = stage_uploaded_file_for_review(db, upload_folder, request_file, base)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/unittest/mock.py", line 1124, in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/unittest/mock.py", line 1128, in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/unittest/mock.py", line 1183, in _execute_mock_call
    raise effect
Exception: Test exception
___________________ test_upload_file_refactored_get_request ____________________

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_refactored_get_request(client):
      """upload_file_refactored handles GET request correctly."""
>     response = client.get('/upload_refactored')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:556: in upload_file_refactored
    return render_upload_page(form, message, 'upload.html', "direct")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/utils/route_upload_helpers.py:284: in render_upload_page
    return render_template(template_name, **template_context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca651a490>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
_________________ test_upload_file_refactored_missing_id_error _________________

message = None

    @main.route('/upload_refactored', methods=['GET', 'POST'])
    @main.route('/upload_refactored/<message>', methods=['GET', 'POST'])
    def upload_file_refactored(message: str | None = None) -> Union[str, Response]:
      """
      Refactored version of upload_file route with improved error handling and structure.
    
      This route provides the same functionality as upload_file but uses a more modular
      approach with better error handling and clearer separation of concerns.
    
      Args:
        message (str | None): Optional message to display on the upload page.
    
      Returns:
        str|Response: Rendered HTML for the upload form, or redirect after upload.
    
      Examples:
        # In browser: GET /upload_refactored
        # Returns: HTML upload form
        # In browser: POST /upload_refactored
        # Redirects to: /incidence_update or error page
      """
      logger.info(f"route called: upload_file_refactored with message: {message}")
    
      base: AutomapBase = current_app.base  # type: ignore[attr-defined]
      form = UploadForm()
    
      # Decode redirect message, if present
      if message:
        message = unquote(message)
        logger.debug(f"Received redirect message: {message}")
    
      upload_folder = get_upload_folder()
      logger.debug(f"Files received: {list(request.files.keys())}, upload_folder={upload_folder}")
    
      if request.method == 'POST':
        flash("_upload_attempted", "internal-marker")
        try:
          request_file = request.files.get('file')
    
          # Validate upload request using shared helper
          is_valid, error_message = validate_upload_request(request_file)
          if not is_valid:
            return render_upload_error_page(form, error_message, 'upload.html', "direct")
    
          logger.debug(f"Received uploaded file: {request_file.filename}")
    
          # Process uploaded file using the new refactored function
          result = upload_and_process_file(db, upload_folder, request_file, base)
    
          if result.success:
            logger.debug(f"Upload successful: id={result.id_}, sector={result.sector}. Redirecting to update page.")
            return redirect(url_for('main.incidence_update', id_=result.id_))
    
          # Handle specific error types based on the result
          if result.error_type == "missing_id":
            logger.warning(f"Upload blocked: missing or invalid id_incidence in {result.file_path.name}")
>           return render_template(
              'upload.html',
              form=form,
              upload_message=(
                "This file is missing a valid 'Incidence/Emission ID' (id_incidence). "
                "Please add a positive integer id_incidence to your spreadsheet before uploading."
              )

source/production/arb/portal/routes.py:516: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca6753710>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_refactored_missing_id_error(client):
      """upload_file_refactored handles missing ID error."""
      with patch('arb.portal.routes.upload_and_process_file') as mock_upload:
        mock_upload.return_value = UploadResult(
          file_path=Path("uploads/test.xlsx"),
          id_=None,
          sector="Dairy Digester",
          success=False,
          error_message="No valid id_incidence found in spreadsheet",
          error_type="missing_id"
        )
    
        data = {'file': (io.BytesIO(b'test file content'), 'test.xlsx')}
>       response = client.post('/upload_refactored', data=data, content_type='multipart/form-data')
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:549: in upload_file_refactored
    return render_template(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca6753710>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
------------------------------ Captured log call -------------------------------
WARNING  arb.portal.routes:routes.py:515 Upload blocked: missing or invalid id_incidence in test.xlsx
ERROR    arb.portal.routes:routes.py:541 Exception occurred during upload or parsing.
Traceback (most recent call last):
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/routes.py", line 516, in upload_file_refactored
    return render_template(
           ^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 150, in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 131, in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 1295, in render
    self.environment.handle_exception()
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 942, in handle_exception
    raise rewrite_traceback_stack(source=source)
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/upload.html", line 1, in top-level template code
    {% extends 'base.html' %}
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/base.html", line 42, in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/includes/navbar.jinja", line 100, in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1121, in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1110, in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py", line 924, in build
    raise BuildError(endpoint, values, method, self)
werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?
_________________ test_upload_file_refactored_conversion_error _________________

message = None

    @main.route('/upload_refactored', methods=['GET', 'POST'])
    @main.route('/upload_refactored/<message>', methods=['GET', 'POST'])
    def upload_file_refactored(message: str | None = None) -> Union[str, Response]:
      """
      Refactored version of upload_file route with improved error handling and structure.
    
      This route provides the same functionality as upload_file but uses a more modular
      approach with better error handling and clearer separation of concerns.
    
      Args:
        message (str | None): Optional message to display on the upload page.
    
      Returns:
        str|Response: Rendered HTML for the upload form, or redirect after upload.
    
      Examples:
        # In browser: GET /upload_refactored
        # Returns: HTML upload form
        # In browser: POST /upload_refactored
        # Redirects to: /incidence_update or error page
      """
      logger.info(f"route called: upload_file_refactored with message: {message}")
    
      base: AutomapBase = current_app.base  # type: ignore[attr-defined]
      form = UploadForm()
    
      # Decode redirect message, if present
      if message:
        message = unquote(message)
        logger.debug(f"Received redirect message: {message}")
    
      upload_folder = get_upload_folder()
      logger.debug(f"Files received: {list(request.files.keys())}, upload_folder={upload_folder}")
    
      if request.method == 'POST':
        flash("_upload_attempted", "internal-marker")
        try:
          request_file = request.files.get('file')
    
          # Validate upload request using shared helper
          is_valid, error_message = validate_upload_request(request_file)
          if not is_valid:
            return render_upload_error_page(form, error_message, 'upload.html', "direct")
    
          logger.debug(f"Received uploaded file: {request_file.filename}")
    
          # Process uploaded file using the new refactored function
          result = upload_and_process_file(db, upload_folder, request_file, base)
    
          if result.success:
            logger.debug(f"Upload successful: id={result.id_}, sector={result.sector}. Redirecting to update page.")
            return redirect(url_for('main.incidence_update', id_=result.id_))
    
          # Handle specific error types based on the result
          if result.error_type == "missing_id":
            logger.warning(f"Upload blocked: missing or invalid id_incidence in {result.file_path.name}")
            return render_template(
              'upload.html',
              form=form,
              upload_message=(
                "This file is missing a valid 'Incidence/Emission ID' (id_incidence). "
                "Please add a positive integer id_incidence to your spreadsheet before uploading."
              )
            )
          elif result.error_type == "conversion_failed":
            logger.warning(f"Upload failed file conversion: {result.file_path=}")
>           return render_template(
              'upload.html',
              form=form,
              upload_message=result.error_message or "Uploaded file format not recognized."
            )

source/production/arb/portal/routes.py:526: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca667c1d0>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_refactored_conversion_error(client):
      """upload_file_refactored handles file conversion error."""
      with patch('arb.portal.routes.upload_and_process_file') as mock_upload:
        mock_upload.return_value = UploadResult(
          file_path=Path("uploads/test.txt"),
          id_=None,
          sector=None,
          success=False,
          error_message="File could not be converted to JSON format",
          error_type="conversion_failed"
        )
    
        data = {'file': (io.BytesIO(b'invalid content'), 'test.txt')}
>       response = client.post('/upload_refactored', data=data, content_type='multipart/form-data')
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:549: in upload_file_refactored
    return render_template(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca667c1d0>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
------------------------------ Captured log call -------------------------------
WARNING  arb.portal.routes:routes.py:525 Upload failed file conversion: result.file_path=PosixPath('uploads/test.txt')
ERROR    arb.portal.routes:routes.py:541 Exception occurred during upload or parsing.
Traceback (most recent call last):
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/routes.py", line 526, in upload_file_refactored
    return render_template(
           ^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 150, in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 131, in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 1295, in render
    self.environment.handle_exception()
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 942, in handle_exception
    raise rewrite_traceback_stack(source=source)
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/upload.html", line 1, in top-level template code
    {% extends 'base.html' %}
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/base.html", line 42, in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/includes/navbar.jinja", line 100, in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1121, in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1110, in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py", line 924, in build
    raise BuildError(endpoint, values, method, self)
werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?
____________________ test_upload_file_refactored_file_error ____________________

message = None

    @main.route('/upload_refactored', methods=['GET', 'POST'])
    @main.route('/upload_refactored/<message>', methods=['GET', 'POST'])
    def upload_file_refactored(message: str | None = None) -> Union[str, Response]:
      """
      Refactored version of upload_file route with improved error handling and structure.
    
      This route provides the same functionality as upload_file but uses a more modular
      approach with better error handling and clearer separation of concerns.
    
      Args:
        message (str | None): Optional message to display on the upload page.
    
      Returns:
        str|Response: Rendered HTML for the upload form, or redirect after upload.
    
      Examples:
        # In browser: GET /upload_refactored
        # Returns: HTML upload form
        # In browser: POST /upload_refactored
        # Redirects to: /incidence_update or error page
      """
      logger.info(f"route called: upload_file_refactored with message: {message}")
    
      base: AutomapBase = current_app.base  # type: ignore[attr-defined]
      form = UploadForm()
    
      # Decode redirect message, if present
      if message:
        message = unquote(message)
        logger.debug(f"Received redirect message: {message}")
    
      upload_folder = get_upload_folder()
      logger.debug(f"Files received: {list(request.files.keys())}, upload_folder={upload_folder}")
    
      if request.method == 'POST':
        flash("_upload_attempted", "internal-marker")
        try:
          request_file = request.files.get('file')
    
          # Validate upload request using shared helper
          is_valid, error_message = validate_upload_request(request_file)
          if not is_valid:
            return render_upload_error_page(form, error_message, 'upload.html', "direct")
    
          logger.debug(f"Received uploaded file: {request_file.filename}")
    
          # Process uploaded file using the new refactored function
          result = upload_and_process_file(db, upload_folder, request_file, base)
    
          if result.success:
            logger.debug(f"Upload successful: id={result.id_}, sector={result.sector}. Redirecting to update page.")
            return redirect(url_for('main.incidence_update', id_=result.id_))
    
          # Handle specific error types based on the result
          if result.error_type == "missing_id":
            logger.warning(f"Upload blocked: missing or invalid id_incidence in {result.file_path.name}")
            return render_template(
              'upload.html',
              form=form,
              upload_message=(
                "This file is missing a valid 'Incidence/Emission ID' (id_incidence). "
                "Please add a positive integer id_incidence to your spreadsheet before uploading."
              )
            )
          elif result.error_type == "conversion_failed":
            logger.warning(f"Upload failed file conversion: {result.file_path=}")
            return render_template(
              'upload.html',
              form=form,
              upload_message=result.error_message or "Uploaded file format not recognized."
            )
          else:
            # Handle other error types
            logger.warning(f"Upload failed: {result.error_type=}, {result.error_message=}")
>           return render_template(
              'upload.html',
              form=form,
              upload_message=result.error_message or "Upload processing failed."
            )

source/production/arb/portal/routes.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca62dbd10>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_refactored_file_error(client):
      """upload_file_refactored handles file processing error."""
      with patch('arb.portal.routes.upload_and_process_file') as mock_upload:
        mock_upload.return_value = UploadResult(
          file_path=Path("unknown"),
          id_=None,
          sector=None,
          success=False,
          error_message="File upload failed",
          error_type="file_error"
        )
    
        data = {'file': (io.BytesIO(b'test content'), 'test.xlsx')}
>       response = client.post('/upload_refactored', data=data, content_type='multipart/form-data')
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:549: in upload_file_refactored
    return render_template(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca62dbd10>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
------------------------------ Captured log call -------------------------------
WARNING  arb.portal.routes:routes.py:533 Upload failed: result.error_type='file_error', result.error_message='File upload failed'
ERROR    arb.portal.routes:routes.py:541 Exception occurred during upload or parsing.
Traceback (most recent call last):
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/routes.py", line 534, in upload_file_refactored
    return render_template(
           ^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 150, in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 131, in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 1295, in render
    self.environment.handle_exception()
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 942, in handle_exception
    raise rewrite_traceback_stack(source=source)
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/upload.html", line 1, in top-level template code
    {% extends 'base.html' %}
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/base.html", line 42, in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/includes/navbar.jinja", line 100, in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1121, in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1110, in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py", line 924, in build
    raise BuildError(endpoint, values, method, self)
werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?
__________________ test_upload_file_refactored_database_error __________________

message = None

    @main.route('/upload_refactored', methods=['GET', 'POST'])
    @main.route('/upload_refactored/<message>', methods=['GET', 'POST'])
    def upload_file_refactored(message: str | None = None) -> Union[str, Response]:
      """
      Refactored version of upload_file route with improved error handling and structure.
    
      This route provides the same functionality as upload_file but uses a more modular
      approach with better error handling and clearer separation of concerns.
    
      Args:
        message (str | None): Optional message to display on the upload page.
    
      Returns:
        str|Response: Rendered HTML for the upload form, or redirect after upload.
    
      Examples:
        # In browser: GET /upload_refactored
        # Returns: HTML upload form
        # In browser: POST /upload_refactored
        # Redirects to: /incidence_update or error page
      """
      logger.info(f"route called: upload_file_refactored with message: {message}")
    
      base: AutomapBase = current_app.base  # type: ignore[attr-defined]
      form = UploadForm()
    
      # Decode redirect message, if present
      if message:
        message = unquote(message)
        logger.debug(f"Received redirect message: {message}")
    
      upload_folder = get_upload_folder()
      logger.debug(f"Files received: {list(request.files.keys())}, upload_folder={upload_folder}")
    
      if request.method == 'POST':
        flash("_upload_attempted", "internal-marker")
        try:
          request_file = request.files.get('file')
    
          # Validate upload request using shared helper
          is_valid, error_message = validate_upload_request(request_file)
          if not is_valid:
            return render_upload_error_page(form, error_message, 'upload.html', "direct")
    
          logger.debug(f"Received uploaded file: {request_file.filename}")
    
          # Process uploaded file using the new refactored function
          result = upload_and_process_file(db, upload_folder, request_file, base)
    
          if result.success:
            logger.debug(f"Upload successful: id={result.id_}, sector={result.sector}. Redirecting to update page.")
            return redirect(url_for('main.incidence_update', id_=result.id_))
    
          # Handle specific error types based on the result
          if result.error_type == "missing_id":
            logger.warning(f"Upload blocked: missing or invalid id_incidence in {result.file_path.name}")
            return render_template(
              'upload.html',
              form=form,
              upload_message=(
                "This file is missing a valid 'Incidence/Emission ID' (id_incidence). "
                "Please add a positive integer id_incidence to your spreadsheet before uploading."
              )
            )
          elif result.error_type == "conversion_failed":
            logger.warning(f"Upload failed file conversion: {result.file_path=}")
            return render_template(
              'upload.html',
              form=form,
              upload_message=result.error_message or "Uploaded file format not recognized."
            )
          else:
            # Handle other error types
            logger.warning(f"Upload failed: {result.error_type=}, {result.error_message=}")
>           return render_template(
              'upload.html',
              form=form,
              upload_message=result.error_message or "Upload processing failed."
            )

source/production/arb/portal/routes.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca6603dd0>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_refactored_database_error(client):
      """upload_file_refactored handles database error."""
      with patch('arb.portal.routes.upload_and_process_file') as mock_upload:
        mock_upload.return_value = UploadResult(
          file_path=Path("uploads/test.xlsx"),
          id_=None,
          sector="Dairy Digester",
          success=False,
          error_message="Database connection failed",
          error_type="database_error"
        )
    
        data = {'file': (io.BytesIO(b'test content'), 'test.xlsx')}
>       response = client.post('/upload_refactored', data=data, content_type='multipart/form-data')
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:348: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:549: in upload_file_refactored
    return render_template(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca6603dd0>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
------------------------------ Captured log call -------------------------------
WARNING  arb.portal.routes:routes.py:533 Upload failed: result.error_type='database_error', result.error_message='Database connection failed'
ERROR    arb.portal.routes:routes.py:541 Exception occurred during upload or parsing.
Traceback (most recent call last):
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/routes.py", line 534, in upload_file_refactored
    return render_template(
           ^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 150, in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 131, in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 1295, in render
    self.environment.handle_exception()
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 942, in handle_exception
    raise rewrite_traceback_stack(source=source)
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/upload.html", line 1, in top-level template code
    {% extends 'base.html' %}
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/base.html", line 42, in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/includes/navbar.jinja", line 100, in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1121, in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1110, in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py", line 924, in build
    raise BuildError(endpoint, values, method, self)
werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?
__________________ test_upload_file_refactored_unknown_error ___________________

message = None

    @main.route('/upload_refactored', methods=['GET', 'POST'])
    @main.route('/upload_refactored/<message>', methods=['GET', 'POST'])
    def upload_file_refactored(message: str | None = None) -> Union[str, Response]:
      """
      Refactored version of upload_file route with improved error handling and structure.
    
      This route provides the same functionality as upload_file but uses a more modular
      approach with better error handling and clearer separation of concerns.
    
      Args:
        message (str | None): Optional message to display on the upload page.
    
      Returns:
        str|Response: Rendered HTML for the upload form, or redirect after upload.
    
      Examples:
        # In browser: GET /upload_refactored
        # Returns: HTML upload form
        # In browser: POST /upload_refactored
        # Redirects to: /incidence_update or error page
      """
      logger.info(f"route called: upload_file_refactored with message: {message}")
    
      base: AutomapBase = current_app.base  # type: ignore[attr-defined]
      form = UploadForm()
    
      # Decode redirect message, if present
      if message:
        message = unquote(message)
        logger.debug(f"Received redirect message: {message}")
    
      upload_folder = get_upload_folder()
      logger.debug(f"Files received: {list(request.files.keys())}, upload_folder={upload_folder}")
    
      if request.method == 'POST':
        flash("_upload_attempted", "internal-marker")
        try:
          request_file = request.files.get('file')
    
          # Validate upload request using shared helper
          is_valid, error_message = validate_upload_request(request_file)
          if not is_valid:
            return render_upload_error_page(form, error_message, 'upload.html', "direct")
    
          logger.debug(f"Received uploaded file: {request_file.filename}")
    
          # Process uploaded file using the new refactored function
          result = upload_and_process_file(db, upload_folder, request_file, base)
    
          if result.success:
            logger.debug(f"Upload successful: id={result.id_}, sector={result.sector}. Redirecting to update page.")
            return redirect(url_for('main.incidence_update', id_=result.id_))
    
          # Handle specific error types based on the result
          if result.error_type == "missing_id":
            logger.warning(f"Upload blocked: missing or invalid id_incidence in {result.file_path.name}")
            return render_template(
              'upload.html',
              form=form,
              upload_message=(
                "This file is missing a valid 'Incidence/Emission ID' (id_incidence). "
                "Please add a positive integer id_incidence to your spreadsheet before uploading."
              )
            )
          elif result.error_type == "conversion_failed":
            logger.warning(f"Upload failed file conversion: {result.file_path=}")
            return render_template(
              'upload.html',
              form=form,
              upload_message=result.error_message or "Uploaded file format not recognized."
            )
          else:
            # Handle other error types
            logger.warning(f"Upload failed: {result.error_type=}, {result.error_message=}")
>           return render_template(
              'upload.html',
              form=form,
              upload_message=result.error_message or "Upload processing failed."
            )

source/production/arb/portal/routes.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca65703d0>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_refactored_unknown_error(client):
      """upload_file_refactored handles unknown error types."""
      with patch('arb.portal.routes.upload_and_process_file') as mock_upload:
        mock_upload.return_value = UploadResult(
          file_path=Path("uploads/test.xlsx"),
          id_=None,
          sector=None,
          success=False,
          error_message="Unexpected error occurred",
          error_type="unknown_error"
        )
    
        data = {'file': (io.BytesIO(b'test content'), 'test.xlsx')}
>       response = client.post('/upload_refactored', data=data, content_type='multipart/form-data')
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:368: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:549: in upload_file_refactored
    return render_template(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca65703d0>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
------------------------------ Captured log call -------------------------------
WARNING  arb.portal.routes:routes.py:533 Upload failed: result.error_type='unknown_error', result.error_message='Unexpected error occurred'
ERROR    arb.portal.routes:routes.py:541 Exception occurred during upload or parsing.
Traceback (most recent call last):
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/routes.py", line 534, in upload_file_refactored
    return render_template(
           ^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 150, in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 131, in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 1295, in render
    self.environment.handle_exception()
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 942, in handle_exception
    raise rewrite_traceback_stack(source=source)
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/upload.html", line 1, in top-level template code
    {% extends 'base.html' %}
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/base.html", line 42, in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/includes/navbar.jinja", line 100, in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1121, in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1110, in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py", line 924, in build
    raise BuildError(endpoint, values, method, self)
werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?
_________________ test_upload_file_refactored_no_file_selected _________________

message = None

    @main.route('/upload_refactored', methods=['GET', 'POST'])
    @main.route('/upload_refactored/<message>', methods=['GET', 'POST'])
    def upload_file_refactored(message: str | None = None) -> Union[str, Response]:
      """
      Refactored version of upload_file route with improved error handling and structure.
    
      This route provides the same functionality as upload_file but uses a more modular
      approach with better error handling and clearer separation of concerns.
    
      Args:
        message (str | None): Optional message to display on the upload page.
    
      Returns:
        str|Response: Rendered HTML for the upload form, or redirect after upload.
    
      Examples:
        # In browser: GET /upload_refactored
        # Returns: HTML upload form
        # In browser: POST /upload_refactored
        # Redirects to: /incidence_update or error page
      """
      logger.info(f"route called: upload_file_refactored with message: {message}")
    
      base: AutomapBase = current_app.base  # type: ignore[attr-defined]
      form = UploadForm()
    
      # Decode redirect message, if present
      if message:
        message = unquote(message)
        logger.debug(f"Received redirect message: {message}")
    
      upload_folder = get_upload_folder()
      logger.debug(f"Files received: {list(request.files.keys())}, upload_folder={upload_folder}")
    
      if request.method == 'POST':
        flash("_upload_attempted", "internal-marker")
        try:
          request_file = request.files.get('file')
    
          # Validate upload request using shared helper
          is_valid, error_message = validate_upload_request(request_file)
          if not is_valid:
>           return render_upload_error_page(form, error_message, 'upload.html', "direct")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

source/production/arb/portal/routes.py:502: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
source/production/arb/portal/utils/route_upload_helpers.py:344: in render_upload_error_page
    return render_template(template_name, **template_context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca5e83990>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_refactored_no_file_selected(client):
      """upload_file_refactored handles no file selected."""
>     response = client.post('/upload_refactored')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:377: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:549: in upload_file_refactored
    return render_template(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca5e83990>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
------------------------------ Captured log call -------------------------------
WARNING  arb.portal.utils.route_upload_helpers:route_upload_helpers.py:50 POST received with no file selected.
ERROR    arb.portal.routes:routes.py:541 Exception occurred during upload or parsing.
Traceback (most recent call last):
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/routes.py", line 502, in upload_file_refactored
    return render_upload_error_page(form, error_message, 'upload.html', "direct")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/utils/route_upload_helpers.py", line 344, in render_upload_error_page
    return render_template(template_name, **template_context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 150, in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py", line 131, in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 1295, in render
    self.environment.handle_exception()
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py", line 942, in handle_exception
    raise rewrite_traceback_stack(source=source)
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/upload.html", line 1, in top-level template code
    {% extends 'base.html' %}
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/base.html", line 42, in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/templates/includes/navbar.jinja", line 100, in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1121, in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py", line 1110, in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py", line 924, in build
    raise BuildError(endpoint, values, method, self)
werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?
______________ test_upload_file_refactored_with_message_parameter ______________

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_refactored_with_message_parameter(client):
      """upload_file_refactored handles message parameter correctly."""
      test_message = "Test%20refactored%20message"
>     response = client.get(f'/upload_refactored/{test_message}')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:386: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:556: in upload_file_refactored
    return render_upload_page(form, message, 'upload.html', "direct")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/utils/route_upload_helpers.py:284: in render_upload_page
    return render_template(template_name, **template_context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca5fee590>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
________________ test_upload_file_refactored_exception_handling ________________

message = None

    @main.route('/upload_refactored', methods=['GET', 'POST'])
    @main.route('/upload_refactored/<message>', methods=['GET', 'POST'])
    def upload_file_refactored(message: str | None = None) -> Union[str, Response]:
      """
      Refactored version of upload_file route with improved error handling and structure.
    
      This route provides the same functionality as upload_file but uses a more modular
      approach with better error handling and clearer separation of concerns.
    
      Args:
        message (str | None): Optional message to display on the upload page.
    
      Returns:
        str|Response: Rendered HTML for the upload form, or redirect after upload.
    
      Examples:
        # In browser: GET /upload_refactored
        # Returns: HTML upload form
        # In browser: POST /upload_refactored
        # Redirects to: /incidence_update or error page
      """
      logger.info(f"route called: upload_file_refactored with message: {message}")
    
      base: AutomapBase = current_app.base  # type: ignore[attr-defined]
      form = UploadForm()
    
      # Decode redirect message, if present
      if message:
        message = unquote(message)
        logger.debug(f"Received redirect message: {message}")
    
      upload_folder = get_upload_folder()
      logger.debug(f"Files received: {list(request.files.keys())}, upload_folder={upload_folder}")
    
      if request.method == 'POST':
        flash("_upload_attempted", "internal-marker")
        try:
          request_file = request.files.get('file')
    
          # Validate upload request using shared helper
          is_valid, error_message = validate_upload_request(request_file)
          if not is_valid:
            return render_upload_error_page(form, error_message, 'upload.html', "direct")
    
          logger.debug(f"Received uploaded file: {request_file.filename}")
    
          # Process uploaded file using the new refactored function
>         result = upload_and_process_file(db, upload_folder, request_file, base)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

source/production/arb/portal/routes.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='upload_and_process_file' id='133919871390288'>
args = (<SQLAlchemy>, PosixPath('/home/tonyh/git_repos/feedback_portal/portal_uploads'), <FileStorage: 'test.xlsx' ('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')>, <class 'sqlalchemy.ext.automap.Base'>)
kwargs = {}, effect = Exception('Unexpected exception')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Unexpected exception

../../miniconda3/envs/mini_conda_02/lib/python3.11/unittest/mock.py:1183: Exception

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'arb.portal.app'>>

    def test_upload_file_refactored_exception_handling(client):
      """upload_file_refactored handles exceptions gracefully."""
      with patch('arb.portal.routes.upload_and_process_file') as mock_upload:
        mock_upload.side_effect = Exception("Unexpected exception")
    
        data = {'file': (io.BytesIO(b'test content'), 'test.xlsx')}
>       response = client.post('/upload_refactored', data=data, content_type='multipart/form-data')
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/arb/portal/test_routes.py:398: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/testing.py:234: in open
    response = super().open(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/routes.py:549: in upload_file_refactored
    return render_template(
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:150: in render_template
    return _render(app, template, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/templating.py:131: in _render
    rv = template.render(context)
         ^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:1295: in render
    self.environment.handle_exception()
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/jinja2/environment.py:942: in handle_exception
    raise rewrite_traceback_stack(source=source)
source/production/arb/portal/templates/upload.html:1: in top-level template code
    {% extends 'base.html' %}
source/production/arb/portal/templates/base.html:42: in top-level template code
    {% include 'includes/navbar.jinja' %}
    ^^^^^^^^^^^^^^^^^^^^^^^^^
source/production/arb/portal/templates/includes/navbar.jinja:100: in top-level template code
    <li><a class="dropdown-item" href="{{ url_for('main.upload_file_unified') }}">Upload Feedback
    ^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1121: in url_for
    return self.handle_url_build_error(error, endpoint, values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/flask/app.py:1110: in url_for
    rv = url_adapter.build(  # type: ignore[union-attr]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <werkzeug.routing.map.MapAdapter object at 0x79cca65cc150>
endpoint = 'main.upload_file_unified', values = {}, method = None
force_external = False, append_unknown = True, url_scheme = None

    def build(
        self,
        endpoint: t.Any,
        values: t.Mapping[str, t.Any] | None = None,
        method: str | None = None,
        force_external: bool = False,
        append_unknown: bool = True,
        url_scheme: str | None = None,
    ) -> str:
        """Building URLs works pretty much the other way round.  Instead of
        `match` you call `build` and pass it the endpoint and a dict of
        arguments for the placeholders.
    
        The `build` function also accepts an argument called `force_external`
        which, if you set it to `True` will force external URLs. Per default
        external URLs (include the server name) will only be used if the
        target URL is on a different subdomain.
    
        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.build("index", {})
        '/'
        >>> urls.build("downloads/show", {'id': 42})
        '/downloads/42'
        >>> urls.build("downloads/show", {'id': 42}, force_external=True)
        'http://example.com/downloads/42'
    
        Because URLs cannot contain non ASCII data you will always get
        bytes back.  Non ASCII characters are urlencoded with the
        charset defined on the map instance.
    
        Additional values are converted to strings and appended to the URL as
        URL querystring parameters:
    
        >>> urls.build("index", {'q': 'My Searchstring'})
        '/?q=My+Searchstring'
    
        When processing those additional values, lists are furthermore
        interpreted as multiple values (as per
        :py:class:`werkzeug.datastructures.MultiDict`):
    
        >>> urls.build("index", {'q': ['a', 'b', 'c']})
        '/?q=a&q=b&q=c'
    
        Passing a ``MultiDict`` will also add multiple values:
    
        >>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
        '/?p=z&q=a&q=b'
    
        If a rule does not exist when building a `BuildError` exception is
        raised.
    
        The build method accepts an argument called `method` which allows you
        to specify the method you want to have an URL built for if you have
        different methods for the same endpoint specified.
    
        :param endpoint: the endpoint of the URL to build.
        :param values: the values for the URL to build.  Unhandled values are
                       appended to the URL as query parameters.
        :param method: the HTTP method for the rule if there are different
                       URLs for different methods on the same endpoint.
        :param force_external: enforce full canonical external URLs. If the URL
                               scheme is not provided, this will generate
                               a protocol-relative URL.
        :param append_unknown: unknown parameters are appended to the generated
                               URL as query string argument.  Disable this
                               if you want the builder to ignore those.
        :param url_scheme: Scheme to use in place of the bound
            :attr:`url_scheme`.
    
        .. versionchanged:: 2.0
            Added the ``url_scheme`` parameter.
    
        .. versionadded:: 0.6
           Added the ``append_unknown`` parameter.
        """
        self.map.update()
    
        if values:
            if isinstance(values, MultiDict):
                values = {
                    k: (v[0] if len(v) == 1 else v)
                    for k, v in dict.items(values)
                    if len(v) != 0
                }
            else:  # plain dict
                values = {k: v for k, v in values.items() if v is not None}
        else:
            values = {}
    
        rv = self._partial_build(endpoint, values, method, append_unknown)
        if rv is None:
>           raise BuildError(endpoint, values, method, self)
E           werkzeug.routing.exceptions.BuildError: Could not build url for endpoint 'main.upload_file_unified'. Did you mean 'main.upload_file_staged' instead?

../../miniconda3/envs/mini_conda_02/lib/python3.11/site-packages/werkzeug/routing/map.py:924: BuildError
------------------------------ Captured log call -------------------------------
ERROR    arb.portal.routes:routes.py:541 Exception occurred during upload or parsing.
Traceback (most recent call last):
  File "/home/tonyh/git_repos/feedback_portal/source/production/arb/portal/routes.py", line 507, in upload_file_refactored
    result = upload_and_process_file(db, upload_folder, request_file, base)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/unittest/mock.py", line 1124, in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/unittest/mock.py", line 1128, in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/tonyh/miniconda3/envs/mini_conda_02/lib/python3.11/unittest/mock.py", line 1183, in _execute_mock_call
    raise effect
Exception: Unexpected exception
============================== slowest durations ===============================
0.15s setup    tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_get_request
0.01s call     tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_get_request

(64 durations < 0.005s hidden.  Use -vv to show these durations.)
=========================== short test summary info ============================
FAILED tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_get_request
FAILED tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_missing_id_error
FAILED tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_conversion_error
FAILED tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_file_error
FAILED tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_database_error
FAILED tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_unknown_error
FAILED tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_no_file_selected
FAILED tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_with_message_parameter
FAILED tests/arb/portal/test_routes.py::test_upload_file_staged_refactored_exception_handling
FAILED tests/arb/portal/test_routes.py::test_upload_file_refactored_get_request
FAILED tests/arb/portal/test_routes.py::test_upload_file_refactored_missing_id_error
FAILED tests/arb/portal/test_routes.py::test_upload_file_refactored_conversion_error
FAILED tests/arb/portal/test_routes.py::test_upload_file_refactored_file_error
FAILED tests/arb/portal/test_routes.py::test_upload_file_refactored_database_error
FAILED tests/arb/portal/test_routes.py::test_upload_file_refactored_unknown_error
FAILED tests/arb/portal/test_routes.py::test_upload_file_refactored_no_file_selected
FAILED tests/arb/portal/test_routes.py::test_upload_file_refactored_with_message_parameter
FAILED tests/arb/portal/test_routes.py::test_upload_file_refactored_exception_handling
========================= 18 failed, 4 passed in 2.03s =========================
